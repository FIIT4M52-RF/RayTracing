# -*- coding: utf-8 -*-
"""RayTracingReflection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11joeTGkTQpHMkMElEiFuQDKNGM7y0Keq
"""

import PIL
import numpy as np
import matplotlib.pyplot as plt
from random import randint
from PIL import Image, ImageDraw

class Light:
    def __init__(self,source_type="point",position=np.array([0.5,0.5,0.5]),intensity=0.5 ):
        self._source_type=source_type
        self._position= np.array(position)
        self._intensity = intensity
    def ComputeLighting(self,P, N):
        if self._source_type == "ambient":
          return self._intensity
        
        n_dot_l = np.dot(N, self.get_L(P))
        if n_dot_l > 0:
          return self._intensity* n_dot_l
        else:
          return 0

    def get_L(self,P):
        if self._source_type == "ambient":
          return np.array((0,0,0))
        elif self._source_type == "point":
          L= self._position - P
        elif self._source_type == "directional":
          L=self._position
        
        L = L/np.linalg.norm(L)
        return np.array(L)

class Sphere:
    def __init__(self, center=np.array([0, 0, 0]), R=1.0, color=np.array([100, 233, 80]), albedo=100, refrect=0):
        self._center = center
        self._R = R
        self._color=np.array(color)
        self.closest_t = np.inf
        self._albedo=albedo
        self._refrect=refrect

    def ray_inter(self, orig, dire):
        closest_sphere = 0
        oc = orig - self._center
        k1 = np.dot(dire, dire)
        k2 = 2*np.dot(oc, dire)
        k3 = np.dot(oc, oc) - self._R ** 2
        discr = k2*k2 - 4*k1*k3
        if discr<0:
          return np.inf
        t1 = (-k2 + np.sqrt(discr)) / (2*k1)
        t2 = (-k2 - np.sqrt(discr)) / (2*k1)
        if t1 < self.closest_t:
            self.closest_t = t1
        if t2 < self.closest_t:
            self.closest_t = t2
        return self.closest_t
    def get_Norm(self,point):
        N = point - self._center
        N = N/np.linalg.norm(N) 
        return np.array(N)

class Render:
  def __init__(self, spheres, lights):
    self.spheres = spheres
    self.lights = lights

  def ray_inter(self, origin, direction, sp):
    c = sp._center
    r = sp._R
    oc = origin - c

    k1 = np.dot(direction, direction)
    k2 = 2*np.dot(oc, direction)
    k3 = np.dot(oc, oc) - r*r

    disc = k2*k2 - 4*k1*k3
    if disc<0:
      return np.inf, np.inf

    t1 = (-k2 + np.sqrt(disc))/(2*k1)
    t2 = (-k2 - np.sqrt(disc))/(2*k1)
    return t1, t2

  def scene_intersect(self, origin, direction):
    t_min = 0.001
    t_max = np.inf
    min_t=np.inf
    s_c = False
    for sp in self.spheres:
      t1, t2 = self.ray_inter(origin, direction, sp)
      #t=sp.ray_inter(origin,direction)
      # if t<min_t:
      #   min_t=t
      #   s_c=sp
      if ( t_min<t1<t_max and t1<min_t):
        min_t = t1
        s_c = sp
      if (t2<min_t):
        min_t = t2
        s_c = sp
    return s_c, min_t

  def render_ref(self,a, b):
    return (2*b*np.dot(b,a) - a)

  def compute_ligh(self, point, N,  dir, albedo):
    intens = 0
    for lg in self.lights:
      if lg._source_type ==  "ambient":
        intens += lg._intensity
      else:
        if lg._source_type == "point":
          L = lg._position - point
        else:
          L = L=self._position

      n_dot_l = np.dot(N, L)

      if(n_dot_l >0):
        intens += lg._intensity*n_dot_l/(np.linalg.norm(N)*np.linalg.norm(L))

      if(albedo!=-1):
        R = self.render_ref(L, N)
        r_dot_v = np.dot(R, dir)
        #print(r_dot_v)
        if r_dot_v>0:
          #print(r_dot_v/(np.linalg.norm(R)*np.linalg.norm(dir)))
          intens += lg._intensity*(pow(r_dot_v/(np.linalg.norm(R)*np.linalg.norm(dir)),albedo))*albedo
          #intens += lg._intensity*(pow(r_dot_v/(np.linalg.norm(R)*np.linalg.norm(dir)),))
          #intens += lg._intensity*pow(r_dot_v/np.linalg.norm(dir), albedo)
          #print(albedo)
          #print(intens)
    return intens

  def render_sp(self,origin,direction,ki):
      sp_w, sp_min = self.scene_intersect(origin, direction)
      if (sp_w==False):
              k = np.array([50, 190, 220]) # background color 
              return k
      #k = sp_w._color
      #intens = 0
      #ref_intens = 0
      point = origin + direction*sp_min
      #direction_n = direction/np.linalg.norm(direction)
      s_c_norm = sp_w.get_Norm(point)

      local_color = sp_w._color*self.compute_ligh(point, s_c_norm, -direction, sp_w._albedo )
      if (ki>6 or sp_w._refrect<=0):
        return local_color
        #return np.array([50, 190, 220])

      reflect_dir = self.render_ref((-direction), s_c_norm)
      reflect_color = self.render_sp(point, -reflect_dir, ki+1)
      #if intens!=0:
        #k = sp_w._color*intens + np.array([1,1,1])*ref_intens*sp_w._albedo + reflect_color*sp_w._refrect
      k = local_color*(1-sp_w._refrect) + reflect_color*sp_w._refrect
      k[0] = 255 if k[0]>255 else k[0]
      k[1] = 255 if k[1]>255 else k[1]
      k[2] = 255 if k[2]>255 else k[2]
      return k


  def show(self, width, height):
    origin=np.array([0, 0, 0])
    fov = np.pi/3.
    Im = np.asarray(Image.new(mode='RGB', size=(width, height), color=(220, 220, 220)))
    Im2 = np.zeros(Im.shape, Im.dtype)
    for i in range(width):
      for j in range(height):
        x =  (2*(i + 0.5)/width  - 1)*np.tan(fov/2.) * width/height
        y = -(2*(j + 0.5)/height - 1)*np.tan(fov/2.)
        direction = np.array([x, y, -1])
        #Im2[j][i] = self.render_math(origin, direction, ki=0)
        Im2[j][i] = self.render_sp(origin, direction, ki=0)
    display(Image.fromarray(Im2, mode='RGB'))


sp1 = Sphere([-1.0, -1.5, -12], 2,[125, 10, 10], 500, refrect=0.5)
sp2 = Sphere([-3,    0,   -16], 2, [75, 0, 130], 30, refrect=0.3)
#sp3 = Sphere([-1.0, -1.5, -12], 5, [10, 10, 125], 100, refrect=0.5)
sp3 = Sphere([7,    5,   -18], 5, [10, 10, 125], 1000, refrect=0.8)
light1 = Light(position=(-20, 20,  20), intensity=1.5)
light3 = Light(position=(30, 20,  30), intensity=2)
light2 = Light("ambient",position=np.array([1,1,1]),intensity=1)
ren = Render((sp1, sp2, sp3), (light1, light2,light3))
# ren = Render((sp3,sp1,sp2,sp4), [light1])
ren.show(480, 320)